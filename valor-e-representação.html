<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2. Valor e Representação</title>
    <link rel="stylesheet" href="estilos/style.css">
    <link rel="stylesheet" href="estilos/phone.css" media="screen and (max-width: 500px)">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
</head>
<body>
    <main>
        <nav id="secao">
            <div id="logo"></div>
            <h1>2. Valor e Representação</h1>
            <ul>
                <li><a href="index.html">1. Fast Inverse Square Root</a></li>
                <li><a href="valor-e-representação.html">2. Valor e Representação</a></li>
                <li><a href="logaritmo.html">3. Logaritmo</a></li>
                <li><a href="resolucao.html">4. Resolução</a></li>
                <li><a href="newton-raphson.html">5. Método Newton-Raphson</a></li>
                <li><a href="implementacao.html">6. Implementação</a></li>
            </ul> 
        </nav>
        <article>
            <section>
                <h1>2. Valor e Representação</h1>

                <p>Existe uma forma padronizada de representar valores flutuantes na computação baseada na notação científica em base \( 2 \) (<em>IEEE 754</em>), já que toda informação é representada em bits. Essa notação é composta por três partes: o <em>sinal</em>, o <em>expoente</em> e a <em>mantissa</em>.</p>

                <aside class="nota">
                    <h3>Nota</h3>

                    <p>Nesse projeto, utilizaremos números de ponto flutuante de 32 bits (<em>IEEE 754 &mdash; single precision</em>) apenas como forma de exemplificação. Em outras precisões &mdash; como 64 bits (<em>double precision</em>) &mdash; o método de interpretação dos bits permanece essencialmente o mesmo.</p>

                    <p>A diferença está no valor do <em>bias</em> associado ao expoente e na quantidade de bits reservados para o expoente e para a mantissa. Ainda assim, a lógica do algoritmo é exatamente a mesma e pode ser aplicada de forma análoga para representações de maior precisão.</p>
                </aside>

                <p>Conforme o padrão <em>IEEE 754</em>:</p>

                <ul>
                    <li>O primeiro bit é reservado para o sinal (\( 0 \) para números positivos, \( 1 \) para negativos);</li>
                    <li>Os 8 bits seguintes representam o expoente com viés;</li>
                    <li>Os 23 bits finais armazenam a mantissa (com a parte fracionária da representação).</li>
                </ul>
                
                <p>Como lidaremos apenas com números positivos, o bit de sinal de todos os valores será sempre igual a \( 0 \).</p>

                <p>O expoente é representado por 8 bits, ou seja, pode assumir valores entre \( 0 \) e \( 255 \). Entretanto, como precisamos representar valores negativos, utilizamos um viés (<em>bias</em>) de \( 127 \), que é subtraído do valor armazenado para obter o valor real do expoente. Dessa forma, obtemos um intervalo efetivo que vai aproximadamente de \( -126 \) a \( +127 \), já que os valores \( 0 \) e \( 255 \) são reservados para casos especiais, como zeros, infinitos e NaNs.</p>

                <p>No caso da mantissa, como o primeiro dígito da notação científica em base \( 2 \) de qualquer binário normalizado é sempre \( 1 \), podemos representá-la armazenando apenas a parte fracionária. Esse primeiro dígito, conhecido como <em>bit implícito</em>, não precisa ser guardado, o que economiza um bit e permite maior precisão na parte fracionária. Valores especiais &mdash; como os citados acima &mdash; não seguem essa normalização, por isso existem os padrões reservados para eles.</p>

                <p>Assim, tendo uma mantissa \( M \) e um expoente \( E \), sabemos que o valor armazenado é <span class="latex-linha">\( V = \left( 1 + \frac{M}{2^{23}} \right) \cdot 2^{E-127} \)</span>. O que devemos perceber é que, se não estivéssemos usando o padrão <em>IEEE 754</em> e lêssemos os bits como um inteiro, o seu valor seria <span class="latex-linha">\( R = 2^{23} \cdot E + M \)</span>.</p>

                <p>Entender como encontrar o valor \( V \) e a representação \( R \) de acordo com o padrão <em>IEEE 754</em> é crucial para a compreensão do funcionamento matemático do algoritmo, como iremos explorar mais adiante.</p>

            </section>
            <nav id="ant-prox">
                <div id="ant">
                    <span>Anterior</span> <br>
                    <a href="index.html">1.Fast Inverse Square Root</a>
                </div>

                <div id="prox">
                    <span>Próximo</span> <br>
                    <a href="logaritmo.html">3. Logaritmo</a>
                </div>
            </nav>
        </article>
    </main>
    
</body>
</html>